---
# WSL2 environment setup and service deployment
- name: "üêß WSL2 Platform Setup"
  hosts: localhost
  gather_facts: yes
  vars_files:
    - group_vars/all.yml
  vars:
    ansible_become_pass: "{{ ansible_sudo_pass | default(omit) }}"

  tasks:
    - name: "üîê Check sudo access"
      block:
        - name: Test sudo access without password
          command: sudo -n true
          register: sudo_check
          failed_when: false
          changed_when: false

        - name: Display sudo access status
          debug:
            msg: |
              üîê Sudo Access Check:
              {% if sudo_check.rc == 0 %}
              ‚úÖ Passwordless sudo is configured - automation will proceed
              {% else %}
              ‚ö†Ô∏è  Sudo requires password - you'll be prompted for your password during setup

              üí° To enable passwordless sudo for better automation (optional):
              1. Run: sudo visudo
              2. Add line: {{ ansible_user_id }} ALL=(ALL) NOPASSWD:ALL
              3. Save and re-run this playbook

              Continuing with password prompts...
              {% endif %}

        - name: Pause if sudo requires password
          pause:
            prompt: |

              üîê This setup requires sudo privileges for:
              - Installing system packages (apt update/install)
              - Setting up certificates and permissions
              - Installing Docker Compose

              You'll be prompted for your password during these operations.

              üí° If tasks appear to hang waiting for password:
              - Press Ctrl+C to cancel
              - Run: sudo echo "sudo test" (to verify password caching)
              - Then re-run this playbook

              Press ENTER to continue, or Ctrl+C to cancel and set up passwordless sudo first.
          when: sudo_check.rc != 0

    - name: "üîç WSL2 Environment Detection"
      block:
        - name: Verify WSL2 environment
          shell: uname -r | grep -i microsoft
          changed_when: false

        - name: Get Windows username
          shell: |
            echo $(/mnt/c/Windows/System32/cmd.exe /c "echo %USERNAME%" 2>/dev/null | tr -d '\r\n')
          register: windows_user_cmd
          changed_when: false

        - name: Set Windows user fact
          set_fact:
            windows_username: "{{ windows_user_cmd.stdout | trim }}"

        - name: Display environment info
          debug:
            msg: |
              üêß WSL2 Environment Detected
              Windows User: {{ windows_username }}
              WSL2 User: {{ ansible_user_id }}
              Home: {{ ansible_env.HOME }}

    # ================================
    # System Packages
    # ================================
    - name: "üì¶ Update package cache"
      block:
        - name: Update apt cache with timeout
          apt:
            update_cache: yes
            cache_valid_time: 3600
          become: yes  # Admin required: Updating system package cache needs root privileges
          async: 300  # 5 minute timeout
          poll: 5     # Check every 5 seconds
          register: apt_update_result

        - name: Display cache update status
          debug:
            msg: |
              üì¶ Package Cache Update:
              {% if apt_update_result.changed %}
              ‚úÖ Package cache updated successfully
              {% else %}
              ‚ÑπÔ∏è  Package cache was already up to date (within 1 hour)
              {% endif %}
      rescue:
        - name: Fallback package cache update
          shell: sudo apt update
          register: apt_update_fallback
          failed_when: apt_update_fallback.rc != 0

        - name: Display fallback result
          debug:
            msg: |
              üì¶ Fallback Cache Update:
              ‚ö†Ô∏è  Standard apt module had issues, used direct command instead
              Exit code: {{ apt_update_fallback.rc }}

    - name: "üì¶ Install base packages"
      apt:
        name:
          - build-essential
          - curl
          - git
          - unzip
          - ca-certificates
          - libssl-dev
          - zlib1g-dev
          - libbz2-dev
          - libreadline-dev
          - libsqlite3-dev
          - libffi-dev
          - gnupg
          - lsb-release
          - libnss3-tools  # Required for mkcert browser certificate trust
          - pipx  # For isolated Python tool installations
          - python3-pip
        state: present
      become: yes  # Admin required: Installing system packages needs root privileges

    # ================================
    # Docker Installation Check
    # ================================
    - name: "üê≥ Check Docker installation"
      command: docker --version
      register: docker_version_check
      failed_when: false
      changed_when: false

    - name: "üê≥ Check Docker daemon"
      command: docker info
      register: docker_daemon_check
      failed_when: false
      changed_when: false

    - name: "‚ö†Ô∏è  Docker setup guidance"
      debug:
        msg: |
          ‚ö†Ô∏è  Docker Configuration Required

          Docker Desktop WSL2 Integration:
          1. Open Docker Desktop on Windows
          2. Go to Settings ‚Üí Resources ‚Üí WSL Integration
          3. Enable integration for this WSL2 distribution
          4. Apply & Restart Docker Desktop
          5. Restart this WSL2 terminal

          Current Status:
          - Docker CLI: {{ '‚úÖ' if docker_version_check.rc == 0 else '‚ùå' }}
          - Docker Daemon: {{ '‚úÖ' if docker_daemon_check.rc == 0 else '‚ùå (Enable WSL2 integration)' }}
      when: docker_version_check.rc != 0 or docker_daemon_check.rc != 0

    - name: "üîç Check Docker proxy configuration"
      shell: docker info --format '{{"{{"}}.HTTPProxy{{"}}"}}'
      register: docker_proxy
      failed_when: false
      changed_when: false
      when: docker_daemon_check.rc == 0

    - name: "üîç Check Docker no-proxy list"
      shell: docker info --format '{{"{{"}}.NoProxy{{"}}"}}'
      register: docker_noproxy
      failed_when: false
      changed_when: false
      when: docker_daemon_check.rc == 0

    - name: "üîß Docker proxy bypass configuration"
      when:
        - docker_daemon_check.rc == 0
        - docker_proxy.stdout != ""
        - "'*.localhost' not in (docker_noproxy.stdout | default(''))"
      block:
        - name: Attempt to fix Docker Desktop proxy settings from WSL2
          shell: |
            DOCKER_SETTINGS="/mnt/c/Users/{{ windows_username }}/AppData/Roaming/Docker/settings.json"
            if [ -f "$DOCKER_SETTINGS" ]; then
              # Backup current settings
              cp "$DOCKER_SETTINGS" "${DOCKER_SETTINGS}.backup"

              # Update the proxy bypass list using Python
              python3 -c "
            import json
            import sys

            settings_path = '$DOCKER_SETTINGS'
            try:
                with open(settings_path, 'r') as f:
                    settings = json.load(f)

                # Check if proxy is configured
                if settings.get('proxyHttpMode') == 'system' or settings.get('overrideProxyHttp'):
                    current_bypass = settings.get('overrideProxyExclude', '')
                    required_domains = 'localhost,*.localhost,127.0.0.1,registry.localhost,traefik.localhost,airflow.localhost'

                    if '*.localhost' not in current_bypass:
                        # Update bypass list
                        if current_bypass:
                            settings['overrideProxyExclude'] = f'{current_bypass},{required_domains}'
                        else:
                            settings['overrideProxyExclude'] = required_domains

                        # Write updated settings
                        with open(settings_path, 'w') as f:
                            json.dump(settings, f, indent=2)

                        print('SUCCESS: Updated Docker Desktop proxy bypass settings')
                        sys.exit(0)
                    else:
                        print('INFO: Docker proxy bypass already configured')
                        sys.exit(0)
                else:
                    print('INFO: Docker not using proxy')
                    sys.exit(0)
            except Exception as e:
                print(f'ERROR: Could not update Docker settings: {e}')
                sys.exit(1)
            "
              exit $?
            else
              echo "Docker settings file not found"
              exit 1
            fi
          register: docker_proxy_fix
          failed_when: false
          changed_when: docker_proxy_fix.rc == 0 and 'SUCCESS' in docker_proxy_fix.stdout

        - name: Docker Desktop restart required
          pause:
            prompt: |

              ‚úÖ Docker Desktop proxy bypass configuration has been updated!

              Docker Desktop needs to be restarted for the changes to take effect:
              1. Right-click Docker Desktop icon in system tray
              2. Select "Restart"
              3. Wait for Docker to fully restart

              After Docker Desktop has restarted, press Enter to continue...
          when: docker_proxy_fix.rc == 0 and 'SUCCESS' in docker_proxy_fix.stdout

        - name: Docker proxy configuration failed - Windows script needed
          pause:
            prompt: |

              ‚ö†Ô∏è  Docker Desktop Proxy Configuration Required!

              Could not automatically update Docker Desktop settings from WSL2.
              The Windows prerequisites script will handle this.

              Please run the Windows script AS ADMINISTRATOR (if not already done):
              - From PowerShell (Run as Administrator): cd \\wsl$\Ubuntu\home\{{ ansible_env.USER }}\repos\airflow-data-platform && .\scripts\win-prereqs.ps1
              - OR from WSL2: powershell.exe -Command "Start-Process powershell -Verb RunAs -ArgumentList '-File scripts/win-prereqs.ps1'"

              Current proxy: {{ docker_proxy.stdout | default('none') }}
              Current bypass list: {{ docker_noproxy.stdout | default('none') }}

              After running the Windows script and restarting Docker Desktop, press Enter to continue...
          when: docker_proxy_fix.rc != 0 or 'ERROR' in docker_proxy_fix.stdout

    # ================================
    # Certificate Management
    # ================================
    - name: "üìÅ Create certificate directory"
      file:
        path: "{{ cert_dir }}"
        state: directory
        mode: '0755'

    - name: "üîê Install mkcert in WSL2"
      block:
        - name: Check if mkcert is already installed
          command: which mkcert
          register: mkcert_installed
          failed_when: false
          changed_when: false

        - name: Download and install mkcert
          block:
            - name: Download mkcert binary
              get_url:
                url: "https://dl.filippo.io/mkcert/latest?for=linux/amd64"
                dest: "/tmp/mkcert-linux-amd64"
                mode: '0755'

            - name: Install mkcert binary
              copy:
                src: "/tmp/mkcert-linux-amd64"
                dest: "/usr/local/bin/mkcert"
                mode: '0755'
                owner: root
                group: root
                remote_src: yes
              become: yes  # Admin required: Installing mkcert binary to /usr/local/bin needs root privileges

            - name: Clean up temporary file
              file:
                path: "/tmp/mkcert-linux-amd64"
                state: absent
          when: mkcert_installed.rc != 0


    - name: "üîê Check for existing certificates"
      stat:
        path: "{{ item }}"
      register: cert_checks
      loop:
        - "/mnt/c/Users/{{ windows_username }}/AppData/Local/mkcert/dev-localhost-wild.crt"
        - "{{ cert_dir }}/dev-localhost-wild.crt"
      failed_when: false

    - name: "üîê Generate certificates on Windows"
      block:
        - name: Prompt to generate certificates
          pause:
            prompt: |

              üîê Certificates need to be generated on Windows!

              Run this in Windows PowerShell (regular user, NO admin needed):
              ================================================================

              # Quick one-liner to run from GitHub:
              irm https://raw.githubusercontent.com/Troubladore/airflow-data-platform/main/scripts/setup-certificates-windows.ps1 | iex

              OR manually:
              ============
              mkcert -install
              cd $env:LOCALAPPDATA\mkcert

              mkcert -cert-file dev-localhost-wild.crt -key-file dev-localhost-wild.key `
                "*.localhost" localhost "traefik.localhost" "registry.localhost" `
                "airflow.localhost" "*.airflow.localhost" 127.0.0.1 ::1

              mkcert -cert-file dev-registry.localhost.crt -key-file dev-registry.localhost.key `
                "registry.localhost" 127.0.0.1 ::1

              Press Enter after generating certificates...
      when: cert_checks.results | selectattr('stat.exists', 'defined') | selectattr('stat.exists') | list | length == 0

    - name: "üîê Copy certificates from Windows"
      block:
        - name: Check if certificates already exist in WSL2
          stat:
            path: "{{ cert_dir }}/dev-localhost-wild.crt"
          register: wsl_cert_check

        - name: Copy certificate files
          copy:
            src: "/mnt/c/Users/{{ windows_username }}/AppData/Local/mkcert/{{ item.src }}"
            dest: "{{ cert_dir }}/{{ item.dest }}"
            mode: "{{ item.mode }}"
          loop:
            - { src: "dev-localhost-wild.crt", dest: "dev-localhost-wild.crt", mode: "0644" }
            - { src: "dev-localhost-wild.key", dest: "dev-localhost-wild.key", mode: "0600" }
            - { src: "dev-registry.localhost.crt", dest: "dev-registry.localhost.crt", mode: "0644" }
            - { src: "dev-registry.localhost.key", dest: "dev-registry.localhost.key", mode: "0600" }
          when: not wsl_cert_check.stat.exists

        - name: Verify certificates copied
          stat:
            path: "{{ cert_dir }}/{{ item }}"
          register: cert_verification
          loop:
            - dev-localhost-wild.crt
            - dev-localhost-wild.key
            - dev-registry.localhost.crt
            - dev-registry.localhost.key

        - name: Display certificate status
          debug:
            msg: |
              üîê Certificates Status:
              {% for result in cert_verification.results %}
              - {{ result.item }}: {{ '‚úÖ' if result.stat.exists else '‚ùå' }}
              {% endfor %}

        - name: Install mkcert CA in WSL2 trust store
          block:
            - name: Set CAROOT environment variable to Windows mkcert location
              set_fact:
                windows_caroot: "/mnt/c/Users/{{ windows_username }}/AppData/Local/mkcert"

            - name: Install CA from Windows mkcert
              shell: |
                export CAROOT="{{ windows_caroot }}"
                mkcert -install
              environment:
                CAROOT: "{{ windows_caroot }}"
              register: ca_install_result
              changed_when: "'installed the local CA' in ca_install_result.stderr or 'updated the local CA' in ca_install_result.stderr"

            - name: Update system certificate trust store
              command: update-ca-certificates
              become: yes  # Admin required: Updating system CA certificates needs root privileges
              register: ca_update_result
              changed_when: "'added' in ca_update_result.stdout"

            - name: Verify CA installation
              command: mkcert -CAROOT
              register: caroot_verify
              changed_when: false

            - name: Display CA installation status
              debug:
                msg: |
                  üîê CA Trust Status:
                  - Windows CAROOT: {{ windows_caroot }}
                  - WSL2 CAROOT: {{ caroot_verify.stdout }}
                  - CA Installation: {{ '‚úÖ' if ca_install_result.rc == 0 else '‚ùå' }}

          when: mkcert_installed.rc == 0 or mkcert_installed.rc != 0

      when: cert_checks.results[0].stat.exists  # Only run if Windows certificates exist


    # ================================
    # Traefik Configuration
    # ================================
    - name: "‚öôÔ∏è  Create Traefik directories"
      file:
        path: "{{ ansible_env.HOME }}/{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - platform-services
        - platform-services/traefik
        - platform-services/traefik/dynamic

    - name: "‚öôÔ∏è  Generate Traefik dynamic TLS configuration"
      copy:
        content: |
          tls:
            certificates:
              # SNI: registry.localhost
              - certFile: "/certs/dev-registry.localhost.crt"
                keyFile: "/certs/dev-registry.localhost.key"
              # SNI: *.localhost (covers airflow-*.customer.localhost, etc.)
              - certFile: "/certs/dev-localhost-wild.crt"
                keyFile: "/certs/dev-localhost-wild.key"
        dest: "{{ ansible_env.HOME }}/platform-services/traefik/dynamic/tls.yml"
        mode: '0644'

    - name: "‚öôÔ∏è  Generate Traefik docker-compose configuration"
      copy:
        content: |
          networks:
            edge:
              name: edge
              driver: bridge

          services:
            traefik:
              image: traefik:{{ traefik_version }}
              command:
                - --providers.docker=true
                - --providers.docker.exposedbydefault=false
                - --providers.docker.network=edge
                - --providers.file.directory=/dynamic
                - --providers.file.watch=true
                - --entrypoints.web.address=:80
                - --entrypoints.websecure.address=:443
                - --api.dashboard=true
              ports:
                - "80:80"
                - "443:443"
              volumes:
                - /var/run/docker.sock:/var/run/docker.sock:ro
                # Mount the certs from WSL2
                - {{ cert_dir }}:/certs:ro
                # Mount the dynamic tls config
                - ./dynamic:/dynamic:ro
              networks:
                - edge
              labels:
                - "traefik.enable=true"
                - "traefik.http.routers.dashboard.rule=Host(`traefik.localhost`)"
                - "traefik.http.routers.dashboard.entrypoints=websecure"
                - "traefik.http.routers.dashboard.tls=true"
                - "traefik.http.routers.dashboard.service=api@internal"
              restart: unless-stopped

            registry:
              image: registry:{{ registry_version }}
              restart: unless-stopped
              environment:
                REGISTRY_HTTP_ADDR: :5000
                REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY: /var/lib/registry
              volumes:
                - registry-data:/var/lib/registry
              networks:
                - edge
              labels:
                - "traefik.enable=true"
                - "traefik.http.routers.registry.rule=Host(`registry.localhost`)"
                - "traefik.http.routers.registry.entrypoints=websecure"
                - "traefik.http.routers.registry.tls=true"
                - "traefik.http.services.registry.loadbalancer.server.port=5000"

          volumes:
            registry-data:
        dest: "{{ ansible_env.HOME }}/platform-services/traefik/docker-compose.yml"
        mode: '0644'

    # ================================
    # Service Deployment
    # ================================
    - name: "üöÄ Deploy platform services"
      block:
        - name: Stop any existing services
          command: docker compose down
          args:
            chdir: "{{ ansible_env.HOME }}/platform-services/traefik"
          failed_when: false

        - name: Start platform services
          command: docker compose up -d
          args:
            chdir: "{{ ansible_env.HOME }}/platform-services/traefik"
          register: services_start

        - name: Wait for services to be ready
          wait_for:
            port: "{{ item }}"
            host: 127.0.0.1
            timeout: 30
          loop:
            - 80
            - 443

        - name: Display service status
          command: docker compose ps
          args:
            chdir: "{{ ansible_env.HOME }}/platform-services/traefik"
          register: service_status

        - debug:
            var: service_status.stdout_lines

      when:
        - docker_daemon_check.rc == 0
        - cert_checks.results | selectattr('stat.exists', 'defined') | selectattr('stat.exists') | list | length > 0

    # ================================
    # Astro CLI Installation
    # ================================
    - name: "üöÄ Check Astro CLI installation"
      command: astro version
      register: astro_check
      failed_when: false
      changed_when: false

    - name: "üöÄ Install Astro CLI (secure binary download)"
      block:
        - name: Get latest Astro CLI release info
          uri:
            url: https://api.github.com/repos/astronomer/astro-cli/releases/latest
            return_content: yes
          register: astro_release

        - name: Download Astro CLI binary
          get_url:
            url: "{{ (astro_release.json.assets | selectattr('name', 'match', '.*linux_amd64.tar.gz$') | first).browser_download_url }}"
            dest: /tmp/astro-cli.tar.gz
            mode: '0644'

        - name: Extract Astro CLI
          unarchive:
            src: /tmp/astro-cli.tar.gz
            dest: /tmp/
            remote_src: yes

        - name: Install Astro CLI binary
          copy:
            src: /tmp/astro
            dest: /usr/local/bin/astro
            mode: '0755'
            owner: root
            group: root
          become: yes  # Admin required: Installing system binaries to /usr/local/bin needs root privileges

        - name: Clean up temporary files
          file:
            path: "{{ item }}"
            state: absent
          loop:
            - /tmp/astro-cli.tar.gz
            - /tmp/astro
      when: astro_check.rc != 0

    - name: "üöÄ Verify Astro CLI installation"
      command: astro version
      register: astro_verify
      when: astro_check.rc != 0

    # ================================
    # Platform Image Building
    # ================================
    - name: "üê≥ Build and push platform Airflow images"
      block:
        - name: Check if platform Airflow image exists in registry
          uri:
            url: "https://registry.localhost/v2/platform/airflow-base/tags/list"
            validate_certs: no
            status_code: [200, 404]
          register: image_check
          failed_when: false

        - name: Build platform Airflow base image (if needed)
          shell: |
            cd {{ playbook_dir }}/../layer1-platform
            docker build -f docker/airflow-base.Dockerfile \
              -t registry.localhost/platform/airflow-base:3.0-10 \
              -t registry.localhost/platform/airflow-base:latest .
          when: image_check.status == 404 or image_check.json.tags is not defined or '3.0-10' not in (image_check.json.tags | default([]))

        - name: Push platform image with all tags to registry
          shell: |
            docker push registry.localhost/platform/airflow-base:3.0-10
            docker push registry.localhost/platform/airflow-base:latest
          when: image_check.status == 404 or image_check.json.tags is not defined or '3.0-10' not in (image_check.json.tags | default([])) or 'latest' not in (image_check.json.tags | default([]))

        - name: Verify platform images in registry
          uri:
            url: "https://registry.localhost/v2/platform/airflow-base/tags/list"
            validate_certs: no
          register: final_image_check

        - debug:
            msg: "‚úÖ Platform Airflow images available: {{ final_image_check.json.tags | join(', ') }}"
          when: final_image_check.json.tags is defined

      when:
        - docker_daemon_check.rc == 0
        - services_start is succeeded

    # ================================
    # WSL2 Setup Summary
    # ================================
    - name: "üìä WSL2 setup summary"
      debug:
        msg: |
          üêß WSL2 Setup Summary:

          System Components:
          - Base packages: ‚úÖ Installed
          - Docker CLI: {{ '‚úÖ' if docker_version_check.rc == 0 else '‚ùå' }}
          - Docker daemon: {{ '‚úÖ' if docker_daemon_check.rc == 0 else '‚ùå' }}
          - Astro CLI: {{ '‚úÖ' if astro_check.rc == 0 or astro_verify is succeeded else '‚ùå' }}

          Platform Services:
          - Certificates: {{ '‚úÖ' if cert_checks.results | selectattr('stat.exists', 'defined') | selectattr('stat.exists') | list | length > 0 else '‚ùå' }}
          - Traefik config: ‚úÖ Generated
          - Services: {{ '‚úÖ Running' if services_start is succeeded else '‚ùå Check Docker' }}
          - Platform Images: {{ '‚úÖ Built' if final_image_check is defined and final_image_check.json.tags is defined else '‚ö†Ô∏è Pending' }}

          Next Steps:
          {% if docker_daemon_check.rc != 0 %}
          1. Enable Docker Desktop WSL2 integration
          2. Re-run this playbook
          {% elif cert_checks.results | selectattr('stat.exists', 'defined') | selectattr('stat.exists') | list | length == 0 %}
          1. Complete Windows certificate setup
          2. Re-run this playbook
          {% else %}
          1. Run validation: ansible-playbook validate-all.yml
          2. Access services:
             - Traefik Dashboard: https://traefik.localhost
             - Container Registry: https://registry.localhost
          {% endif %}
