"""PostgreSQL actions - GREEN phase implementation.

Key Design Decision: The 'prebuilt' Flag
=========================================
The prebuilt flag controls whether the platform LAYERS CUSTOMIZATIONS on the image,
NOT whether we pull it from the registry.

- prebuilt=false (default): Platform may add SSL certificates, Kerberos config,
  corporate CA certs, or other customizations at runtime or build time
- prebuilt=true: Use the image AS-IS without any platform modifications
  (image already has everything needed)

Both modes may need to pull the image from a Docker registry.
"""

from typing import Dict, Any
from wizard.utils.diagnostics import DiagnosticCollector, ServiceDiagnostics, create_diagnostic_summary


def save_config(ctx: Dict[str, Any], runner) -> None:
    """Save PostgreSQL configuration to platform-config.yaml and create .env file.

    Builds configuration dictionary from context and calls runner.save_config.
    Also creates platform-infrastructure/.env file required by Makefile.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects
    """
    # Build config dictionary
    # Map require_password boolean to auth_method
    require_password = ctx.get('services.postgres.require_password', True)
    auth_method = 'md5' if require_password else 'trust'
    password = ctx.get('services.postgres.password', 'changeme') if require_password else None

    # Store derived values back into state for later access
    ctx['services.postgres.auth_method'] = auth_method
    if password is not None:
        ctx['services.postgres.password'] = password

    config = {
        'services': {
            'postgres': {
                'enabled': True,
                'image': ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
                'prebuilt': ctx.get('services.postgres.prebuilt', False),
                'auth_method': auth_method,
                'password': password
            }
        }
    }

    # Call runner to save config
    runner.save_config(config, 'platform-config.yaml')

    # Create .env file for platform-bootstrap (central configuration)
    # This file is loaded by both Makefile and docker-compose.yml
    env_content = _build_env_file_content(
        platform_password=password or '',
        image=ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
        openmetadata_enabled=ctx.get('services.openmetadata.enabled', False),
        kerberos_enabled=ctx.get('services.kerberos.enabled', False),
        pagila_enabled=ctx.get('services.pagila.enabled', False)
    )
    runner.write_file('platform-bootstrap/.env', env_content)


def _build_env_file_content(
    platform_password: str,
    image: str,
    openmetadata_enabled: bool = False,
    kerberos_enabled: bool = False,
    pagila_enabled: bool = False
) -> str:
    """Build .env file content from configuration values.

    Args:
        platform_password: PLATFORM_DB_PASSWORD value
        image: PostgreSQL image URL (optional, only included if non-default)
        openmetadata_enabled: Whether OpenMetadata service is enabled
        kerberos_enabled: Whether Kerberos service is enabled
        pagila_enabled: Whether Pagila service is enabled

    Returns:
        Complete .env file content as string
    """
    lines = [
        "# Platform Bootstrap Configuration",
        "# Auto-generated by wizard - DO NOT EDIT MANUALLY",
        "# Modify via: python -m wizard or ./platform setup",
        "",
        "# Service Enable Flags",
        f"ENABLE_OPENMETADATA={'true' if openmetadata_enabled else 'false'}",
        f"ENABLE_KERBEROS={'true' if kerberos_enabled else 'false'}",
        f"ENABLE_PAGILA={'true' if pagila_enabled else 'false'}",
        "",
        "# PostgreSQL Configuration",
        f"PLATFORM_DB_PASSWORD={platform_password}",
        ""
    ]

    # Only include service passwords if those services are enabled
    if openmetadata_enabled:
        lines.extend([
            "# Service user passwords",
            "OPENMETADATA_DB_PASSWORD=changeme_openmetadata_password",
            ""
        ])

    # Only include IMAGE_POSTGRES if it's not the default
    if image != 'postgres:17.5-alpine':
        lines.extend([
            "# Custom Image Source",
            f"IMAGE_POSTGRES={image}",
            ""
        ])

    return '\n'.join(lines)


def pull_image(ctx: Dict[str, Any], runner) -> None:
    """Pull PostgreSQL Docker image.

    The prebuilt flag controls whether we layer customizations on the image,
    NOT whether we pull it. Both modes may need to pull from registry.

    For corporate registry images (detected by having slashes), check if they
    exist locally first to avoid failing pulls from non-existent registries.

    Args:
        ctx: Context dictionary with image URL and prebuilt flag
        runner: ActionRunner instance for side effects
    """
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')
    prebuilt = ctx.get('services.postgres.prebuilt', False)

    # Check if this looks like a corporate registry image (has registry path)
    is_corporate_image = '/' in image.split(':')[0]  # Has registry/path before tag

    if is_corporate_image:
        # Check if image exists locally first
        check_result = runner.run_shell(['docker', 'image', 'inspect', image])
        if check_result.get('returncode') == 0:
            # Image exists locally
            if prebuilt:
                runner.display(f"\n‚úì Prebuilt image already exists locally: {image}")
            else:
                runner.display(f"\n‚úì Image already exists locally: {image}")
            return

    # Image doesn't exist locally or is from Docker Hub - attempt pull
    if prebuilt:
        runner.display(f"\nPulling prebuilt image (will use as-is): {image}")
    else:
        runner.display(f"\nPulling Docker image: {image}")

    # Pull the image from registry
    result = runner.run_shell(['docker', 'pull', image])

    if result.get('returncode') == 0:
        if prebuilt:
            runner.display(f"‚úì Prebuilt image ready (no customizations): {image}")
        else:
            runner.display(f"‚úì Image pulled: {image}")
    else:
        runner.display(f"‚úó Failed to pull image: {image}")


def start_service(ctx: Dict[str, Any], runner) -> None:
    """Start PostgreSQL service with automatic diagnostics on failure.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects
    """
    runner.display("Starting PostgreSQL service...")

    # Show configuration being used
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')
    auth_method = ctx.get('services.postgres.auth_method', 'trust')

    runner.display(f"  Image: {image}")
    runner.display(f"  Auth: {auth_method} {'(no password)' if auth_method == 'trust' else '(password required)'}")

    # Build command
    command = ['make', '-C', 'platform-infrastructure', 'start']

    # Execute command
    result = runner.run_shell(command)

    if result.get('returncode') == 0:
        runner.display("‚úì PostgreSQL started successfully")
    else:
        runner.display("‚úó PostgreSQL failed to start")
        runner.display("")
        runner.display("Running automatic diagnostics...")
        runner.display("")

        # Run comprehensive diagnostics automatically
        _run_postgres_diagnostics(ctx, runner, result)

def _run_postgres_diagnostics(ctx: Dict[str, Any], runner, start_result) -> None:
    """Run automatic diagnostics when PostgreSQL fails to start.

    Args:
        ctx: Service context
        runner: Action runner
        start_result: Result from failed startup command
    """
    runner.display("")
    runner.display("Running automatic diagnostics...")
    runner.display("")

    # Create diagnostic collector
    collector = DiagnosticCollector()
    service_diag = ServiceDiagnostics(runner)

    # Record the failure
    error_msg = start_result.get('stderr', '') or start_result.get('stdout', '') or 'Unknown error'
    collector.record_failure(
        service="postgres",
        phase="docker_compose_up",
        error=error_msg[:200],  # Truncate long errors
        context={
            "image": ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
            "auth_method": ctx.get('services.postgres.auth_method', 'trust'),
            "port": ctx.get('services.postgres.port', 5432),
            "command": "make -C platform-infrastructure start"
        }
    )

    # Run PostgreSQL-specific diagnostics
    diag_result = service_diag.diagnose_postgres_failure(ctx)

    # Display key findings based on diagnostic results
    if not diag_result.get('container_exists'):
        runner.display("‚ùå Container was not created - Docker Compose failed")

        # Check docker-compose validation
        compose_check = runner.run_shell(
            ['docker', 'compose', '-f', 'platform-infrastructure/docker-compose.yml', 'config']
        )
        if compose_check.get('returncode') != 0:
            runner.display("  ‚Ä¢ docker-compose.yml has syntax errors")
    else:
        runner.display("‚ö† Container was created but failed to start/stay running")

        # Get container logs
        logs_result = runner.run_shell(['docker', 'logs', 'platform-postgres', '--tail', '20'])
        if logs_result.get('stderr'):
            runner.display("  ‚Ä¢ Container error:")
            for line in logs_result.get('stderr', '').split('\n')[:3]:
                if line.strip():
                    runner.display(f"    {line}")

    # Check image status
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')
    image_check = runner.run_shell(['docker', 'image', 'inspect', image])

    if image_check.get('returncode') != 0:
        runner.display(f"üì¶ Image not found locally: {image}")

        # Check if it's a corporate registry
        if '/' in image.split(':')[0]:
            runner.display("  ‚Ä¢ Corporate registry detected")
            runner.display(f"  ‚Ä¢ Try: docker pull {image}")
            runner.display(f"  ‚Ä¢ May need: docker login {image.split('/')[0]}")

    # Parse common error patterns
    if 'connection refused' in error_msg.lower() or 'dial tcp' in error_msg.lower():
        runner.display("üîå Cannot connect to Docker registry")
        registry = image.split('/')[0] if '/' in image else 'registry'
        runner.display(f"  ‚Ä¢ Registry unreachable: {registry}")
        runner.display("  ‚Ä¢ Check network connectivity")
        runner.display("  ‚Ä¢ Verify registry URL is correct")
        if 'fake.registry' in image or 'test.registry' in image:
            runner.display("  ‚ö†Ô∏è  This appears to be a test/mock registry URL")
            runner.display("  ‚Ä¢ Use a real image or create a mock with ./mock-corporate-image.py")

    elif 'pull access denied' in error_msg.lower():
        runner.display("üîí Registry authentication required")
        runner.display(f"  ‚Ä¢ Run: docker login {image.split('/')[0]}")

    elif 'manifest unknown' in error_msg.lower() or 'manifest for' in error_msg.lower():
        runner.display("‚ùå Image not found in registry")
        runner.display(f"  ‚Ä¢ Verify image exists: {image}")

    elif 'toomanyrequests' in error_msg.lower():
        runner.display("‚è±Ô∏è Docker Hub rate limit exceeded")
        runner.display("  ‚Ä¢ Wait 6 hours or authenticate: docker login")

    elif 'address already in use' in error_msg.lower():
        runner.display("üîí Port 5432 is already in use")

        # Check what's using the port
        port_check = runner.run_shell(['lsof', '-i', ':5432'])
        if port_check.get('stdout'):
            runner.display("  ‚Ä¢ Process using port:")
            for line in port_check.get('stdout', '').split('\n')[:2]:
                if line.strip():
                    runner.display(f"    {line}")

    elif 'no space left' in error_msg.lower():
        runner.display("üíæ Disk space issue")
        runner.display("  ‚Ä¢ Clean up: docker system prune -a")

    elif 'no such file or directory' in error_msg.lower():
        runner.display("üìÅ Missing file or directory")
        runner.display("  ‚Ä¢ Check if platform-infrastructure directory exists")
        runner.display("  ‚Ä¢ Verify .env file is present: ls -la platform-bootstrap/.env")
        runner.display("  ‚Ä¢ Ensure docker-compose.yml exists")

        # Check for common missing files
        if not runner.run_shell(['test', '-d', 'platform-infrastructure']).get('returncode') == 0:
            runner.display("  ‚ùå platform-infrastructure directory is missing!")
        elif not runner.run_shell(['test', '-f', 'platform-bootstrap/.env']).get('returncode') == 0:
            runner.display("  ‚ùå platform-bootstrap/.env is missing!")
            runner.display("  ‚Ä¢ Run: ./platform setup")

    # Check if no-password mode issue
    if ctx.get('services.postgres.auth_method') == 'trust':
        runner.display("‚ÑπÔ∏è Using no-password mode (trust authentication)")
        if 'PLATFORM_DB_PASSWORD' in error_msg:
            runner.display("  ‚Ä¢ Config mismatch: password env var set but trust mode enabled")

    # Save detailed log
    log_file = collector.save_log()
    runner.display("")
    runner.display(f"üíæ Full diagnostics saved to: {log_file}")
    runner.display(f"   View with: cat {log_file}")
    runner.display("")
    runner.display("Next steps:")
    runner.display("  1. Review the errors above")
    if '/' in image.split(':')[0]:
        runner.display("  2. If using corporate registry, ensure docker login completed")
    runner.display("  3. Try manual start: cd platform-infrastructure && docker compose up")
    runner.display("  4. Share the diagnostic log if requesting help")
