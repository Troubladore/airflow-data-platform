"""PostgreSQL actions - GREEN phase implementation.

Note: PostgreSQL uses Docker images directly without any building or layering.
Unlike services like Kerberos that install additional packages via Dockerfile,
PostgreSQL simply uses the provided image as-is with configuration through
environment variables and mounted initialization scripts.
"""

from typing import Dict, Any
from wizard.utils.diagnostics import DiagnosticCollector, ServiceDiagnostics, create_diagnostic_summary


def save_config(ctx: Dict[str, Any], runner) -> None:
    """Save PostgreSQL configuration to platform-config.yaml and create .env file.

    Builds configuration dictionary from context and calls runner.save_config.
    Also creates platform-infrastructure/.env file required by Makefile.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects
    """
    # Build config dictionary
    # Map require_password boolean to auth_method
    require_password = ctx.get('services.postgres.require_password', True)
    auth_method = 'md5' if require_password else 'trust'
    password = ctx.get('services.postgres.password', 'changeme') if require_password else None

    # Store derived values back into state for later access
    ctx['services.postgres.auth_method'] = auth_method
    if password is not None:
        ctx['services.postgres.password'] = password

    config = {
        'services': {
            'postgres': {
                'enabled': True,
                'image': ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
                'auth_method': auth_method,
                'password': password
            }
        }
    }

    # Call runner to save config
    runner.save_config(config, 'platform-config.yaml')

    # Create .env file for platform-bootstrap (central configuration)
    # This file is loaded by both Makefile and docker-compose.yml
    env_content = _build_env_file_content(
        platform_password=password or '',
        image=ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
        openmetadata_enabled=ctx.get('services.openmetadata.enabled', False),
        kerberos_enabled=ctx.get('services.kerberos.enabled', False),
        pagila_enabled=ctx.get('services.pagila.enabled', False)
    )
    runner.write_file('platform-bootstrap/.env', env_content)


def _build_env_file_content(
    platform_password: str,
    image: str,
    openmetadata_enabled: bool = False,
    kerberos_enabled: bool = False,
    pagila_enabled: bool = False
) -> str:
    """Build .env file content from configuration values.

    Args:
        platform_password: PLATFORM_DB_PASSWORD value
        image: PostgreSQL image URL (optional, only included if non-default)
        openmetadata_enabled: Whether OpenMetadata service is enabled
        kerberos_enabled: Whether Kerberos service is enabled
        pagila_enabled: Whether Pagila service is enabled

    Returns:
        Complete .env file content as string
    """
    lines = [
        "# Platform Bootstrap Configuration",
        "# Auto-generated by wizard - DO NOT EDIT MANUALLY",
        "# Modify via: python -m wizard or ./platform setup",
        "",
        "# Service Enable Flags",
        f"ENABLE_OPENMETADATA={'true' if openmetadata_enabled else 'false'}",
        f"ENABLE_KERBEROS={'true' if kerberos_enabled else 'false'}",
        f"ENABLE_PAGILA={'true' if pagila_enabled else 'false'}",
        "",
        "# PostgreSQL Configuration",
        f"PLATFORM_DB_PASSWORD={platform_password}",
        ""
    ]

    # Only include service passwords if those services are enabled
    if openmetadata_enabled:
        lines.extend([
            "# Service user passwords",
            "OPENMETADATA_DB_PASSWORD=changeme_openmetadata_password",
            ""
        ])

    # Only include IMAGE_POSTGRES if it's not the default
    if image != 'postgres:17.5-alpine':
        lines.extend([
            "# Custom Image Source",
            f"IMAGE_POSTGRES={image}",
            ""
        ])

    return '\n'.join(lines)


def pull_image(ctx: Dict[str, Any], runner) -> None:
    """Pull PostgreSQL Docker image if not already available locally.

    For corporate registry images (detected by having slashes), check if they
    exist locally first to avoid failing pulls from non-existent registries.

    Args:
        ctx: Context dictionary with image URL
        runner: ActionRunner instance for side effects
    """
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')

    # Check if this looks like a corporate registry image (has registry path)
    is_corporate_image = '/' in image.split(':')[0]  # Has registry/path before tag

    if is_corporate_image:
        # Check if image exists locally first
        check_result = runner.run_shell(['docker', 'image', 'inspect', image])
        if check_result.get('returncode') == 0:
            # Image exists locally
            runner.display(f"\n‚úì Image already exists locally: {image}")
            return

    # Image doesn't exist locally or is from Docker Hub - attempt pull
    runner.display(f"\nPulling Docker image: {image}")

    # Pull the image from registry
    result = runner.run_shell(['docker', 'pull', image])

    if result.get('returncode') == 0:
        runner.display(f"‚úì Image pulled: {image}")
    else:
        runner.display(f"‚úó Failed to pull image: {image}")


def start_service(ctx: Dict[str, Any], runner) -> None:
    """Start PostgreSQL service with automatic diagnostics on failure.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects
    """
    runner.display("Starting PostgreSQL service...")

    # Show configuration being used
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')
    auth_method = ctx.get('services.postgres.auth_method', 'trust')

    runner.display(f"  Image: {image}")
    runner.display(f"  Auth: {auth_method} {'(no password)' if auth_method == 'trust' else '(password required)'}")

    # Build command
    command = ['make', '-C', 'platform-infrastructure', 'start']

    # Execute command
    result = runner.run_shell(command)

    if result.get('returncode') == 0:
        runner.display("‚úì PostgreSQL started successfully")
    else:
        runner.display("‚úó PostgreSQL failed to start")
        runner.display("")
        runner.display("Running automatic diagnostics...")
        runner.display("")

        # Run comprehensive diagnostics automatically
        _run_postgres_diagnostics(ctx, runner, result)

def _run_postgres_diagnostics(ctx: Dict[str, Any], runner, start_result) -> None:
    """Run automatic diagnostics when PostgreSQL fails to start.

    Args:
        ctx: Service context
        runner: Action runner
        start_result: Result from failed startup command
    """
    runner.display("")
    runner.display("Running automatic diagnostics...")
    runner.display("")

    # Create diagnostic collector
    collector = DiagnosticCollector()
    service_diag = ServiceDiagnostics(runner)

    # Record the failure with working directory context
    error_msg = start_result.get('stderr', '') or start_result.get('stdout', '') or 'Unknown error'

    # Get current working directory for diagnostics
    pwd_result = runner.run_shell(['pwd'])
    current_dir = pwd_result.get('stdout', '').strip() if pwd_result else 'unknown'

    collector.record_failure(
        service="postgres",
        phase="docker_compose_up",
        error=error_msg[:200],  # Truncate long errors
        context={
            "image": ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
            "auth_method": ctx.get('services.postgres.auth_method', 'trust'),
            "port": ctx.get('services.postgres.port', 5432),
            "command": "make -C platform-infrastructure start",
            "working_directory": current_dir,
            "attempted_path": "platform-infrastructure"
        }
    )

    # Run PostgreSQL-specific diagnostics
    diag_result = service_diag.diagnose_postgres_failure(ctx)

    # Display key findings based on diagnostic results
    if not diag_result.get('container_exists'):
        runner.display("‚ùå Container was not created - Docker Compose failed")

        # Check docker-compose validation
        compose_check = runner.run_shell(
            ['docker', 'compose', '-f', 'platform-infrastructure/docker-compose.yml', 'config']
        )
        if compose_check.get('returncode') != 0:
            runner.display("  ‚Ä¢ docker-compose.yml has syntax errors")
    else:
        runner.display("‚ö† Container was created but failed to start/stay running")

        # Get container logs
        logs_result = runner.run_shell(['docker', 'logs', 'platform-postgres', '--tail', '20'])
        if logs_result.get('stderr'):
            runner.display("  ‚Ä¢ Container error:")
            for line in logs_result.get('stderr', '').split('\n')[:3]:
                if line.strip():
                    runner.display(f"    {line}")

    # Check image status
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')
    image_check = runner.run_shell(['docker', 'image', 'inspect', image])

    if image_check.get('returncode') != 0:
        runner.display(f"üì¶ Image not found locally: {image}")

        # Check if it's a corporate registry
        if '/' in image.split(':')[0]:
            runner.display("  ‚Ä¢ Corporate registry detected")
            runner.display(f"  ‚Ä¢ Try: docker pull {image}")
            runner.display(f"  ‚Ä¢ May need: docker login {image.split('/')[0]}")

    # Parse common error patterns
    if 'connection refused' in error_msg.lower() or 'dial tcp' in error_msg.lower():
        runner.display("üîå Cannot connect to Docker registry")
        registry = image.split('/')[0] if '/' in image else 'registry'
        runner.display(f"  ‚Ä¢ Registry unreachable: {registry}")
        runner.display("  ‚Ä¢ Check network connectivity")
        runner.display("  ‚Ä¢ Verify registry URL is correct")
        if 'fake.registry' in image or 'test.registry' in image:
            runner.display("  ‚ö†Ô∏è  This appears to be a test/mock registry URL")
            runner.display("  ‚Ä¢ Use a real image or create a mock with ./mock-corporate-image.py")

    elif 'pull access denied' in error_msg.lower():
        runner.display("üîí Registry authentication required")
        runner.display(f"  ‚Ä¢ Run: docker login {image.split('/')[0]}")

    elif 'manifest unknown' in error_msg.lower() or 'manifest for' in error_msg.lower():
        runner.display("‚ùå Image not found in registry")
        runner.display(f"  ‚Ä¢ Verify image exists: {image}")

    elif 'toomanyrequests' in error_msg.lower():
        runner.display("‚è±Ô∏è Docker Hub rate limit exceeded")
        runner.display("  ‚Ä¢ Wait 6 hours or authenticate: docker login")

    elif 'address already in use' in error_msg.lower():
        runner.display("üîí Port 5432 is already in use")

        # Check what's using the port
        port_check = runner.run_shell(['lsof', '-i', ':5432'])
        if port_check.get('stdout'):
            runner.display("  ‚Ä¢ Process using port:")
            for line in port_check.get('stdout', '').split('\n')[:2]:
                if line.strip():
                    runner.display(f"    {line}")

    elif 'no space left' in error_msg.lower():
        runner.display("üíæ Disk space issue")
        runner.display("  ‚Ä¢ Clean up: docker system prune -a")

    elif 'no such file or directory' in error_msg.lower():
        runner.display("üìÅ Missing file or directory")

        # Show current working directory
        pwd_check = runner.run_shell(['pwd'])
        current_dir = pwd_check.get('stdout', '').strip() if pwd_check else 'unknown'
        runner.display(f"  ‚Ä¢ Current directory: {current_dir}")

        # The make command tries to change to platform-infrastructure
        runner.display("  ‚Ä¢ Command tried: make -C platform-infrastructure start")
        runner.display("  ‚Ä¢ This attempts to change to: platform-infrastructure/")

        # Check what exists from current location
        ls_result = runner.run_shell(['ls', '-la'])
        if ls_result.get('returncode') == 0:
            output_lines = ls_result.get('stdout', '').split('\n')
            has_platform_infra = any('platform-infrastructure' in line for line in output_lines)

            if not has_platform_infra:
                runner.display("  ‚ùå platform-infrastructure not found in current directory!")
                runner.display(f"  ‚Ä¢ Make sure you're running from the repo root")

        # Check specific paths
        checks = [
            ('platform-infrastructure', "Main infrastructure directory"),
            ('platform-infrastructure/Makefile', "Infrastructure Makefile"),
            ('platform-infrastructure/docker-compose.yml', "Docker Compose file"),
            ('platform-infrastructure/.env', "Infrastructure env file"),
            ('platform-bootstrap/.env', "Bootstrap env file")
        ]

        for path, description in checks:
            test_result = runner.run_shell(['test', '-e', path])
            if test_result.get('returncode') != 0:
                runner.display(f"  ‚ùå Missing: {path} ({description})")

                # If it's a symlink, check if it's broken
                link_check = runner.run_shell(['test', '-L', path])
                if link_check.get('returncode') == 0:
                    runner.display(f"     ‚Üí It's a broken symlink!")

    # Check if no-password mode issue
    if ctx.get('services.postgres.auth_method') == 'trust':
        runner.display("‚ÑπÔ∏è Using no-password mode (trust authentication)")
        if 'PLATFORM_DB_PASSWORD' in error_msg:
            runner.display("  ‚Ä¢ Config mismatch: password env var set but trust mode enabled")

    # Save detailed log
    log_file = collector.save_log()
    runner.display("")
    runner.display(f"üíæ Full diagnostics saved to: {log_file}")
    runner.display(f"   View with: cat {log_file}")
    runner.display("")
    runner.display("Next steps:")
    runner.display("  1. Review the errors above")
    if '/' in image.split(':')[0]:
        runner.display("  2. If using corporate registry, ensure docker login completed")
    runner.display("  3. Try manual start: cd platform-infrastructure && docker compose up")
    runner.display("  4. Share the diagnostic log if requesting help")
