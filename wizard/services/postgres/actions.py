"""PostgreSQL actions - GREEN phase implementation.

Key Design Decision: The 'prebuilt' Flag
=========================================
The prebuilt flag controls whether the platform LAYERS CUSTOMIZATIONS on the image,
NOT whether we pull it from the registry.

- prebuilt=false (default): Platform may add SSL certificates, Kerberos config,
  corporate CA certs, or other customizations at runtime or build time
- prebuilt=true: Use the image AS-IS without any platform modifications
  (image already has everything needed)

Both modes may need to pull the image from a Docker registry.
"""

from typing import Dict, Any


def save_config(ctx: Dict[str, Any], runner) -> None:
    """Save PostgreSQL configuration to platform-config.yaml and create .env file.

    Builds configuration dictionary from context and calls runner.save_config.
    Also creates platform-infrastructure/.env file required by Makefile.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects
    """
    # Build config dictionary
    # Map require_password boolean to auth_method
    require_password = ctx.get('services.postgres.require_password', True)
    auth_method = 'md5' if require_password else 'trust'
    password = ctx.get('services.postgres.password', 'changeme') if require_password else None

    # Store derived values back into state for later access
    ctx['services.postgres.auth_method'] = auth_method
    if password is not None:
        ctx['services.postgres.password'] = password

    config = {
        'services': {
            'postgres': {
                'enabled': True,
                'image': ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
                'prebuilt': ctx.get('services.postgres.prebuilt', False),
                'auth_method': auth_method,
                'password': password
            }
        }
    }

    # Call runner to save config
    runner.save_config(config, 'platform-config.yaml')

    # Create .env file for platform-bootstrap (central configuration)
    # This file is loaded by both Makefile and docker-compose.yml
    env_content = _build_env_file_content(
        platform_password=password or '',
        image=ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
        openmetadata_enabled=ctx.get('services.openmetadata.enabled', False),
        kerberos_enabled=ctx.get('services.kerberos.enabled', False),
        pagila_enabled=ctx.get('services.pagila.enabled', False)
    )
    runner.write_file('platform-bootstrap/.env', env_content)


def _build_env_file_content(
    platform_password: str,
    image: str,
    openmetadata_enabled: bool = False,
    kerberos_enabled: bool = False,
    pagila_enabled: bool = False
) -> str:
    """Build .env file content from configuration values.

    Args:
        platform_password: PLATFORM_DB_PASSWORD value
        image: PostgreSQL image URL (optional, only included if non-default)
        openmetadata_enabled: Whether OpenMetadata service is enabled
        kerberos_enabled: Whether Kerberos service is enabled
        pagila_enabled: Whether Pagila service is enabled

    Returns:
        Complete .env file content as string
    """
    lines = [
        "# Platform Bootstrap Configuration",
        "# Auto-generated by wizard - DO NOT EDIT MANUALLY",
        "# Modify via: python -m wizard or ./platform setup",
        "",
        "# Service Enable Flags",
        f"ENABLE_OPENMETADATA={'true' if openmetadata_enabled else 'false'}",
        f"ENABLE_KERBEROS={'true' if kerberos_enabled else 'false'}",
        f"ENABLE_PAGILA={'true' if pagila_enabled else 'false'}",
        "",
        "# PostgreSQL Configuration",
        f"PLATFORM_DB_PASSWORD={platform_password}",
        ""
    ]

    # Only include service passwords if those services are enabled
    if openmetadata_enabled:
        lines.extend([
            "# Service user passwords",
            "OPENMETADATA_DB_PASSWORD=changeme_openmetadata_password",
            ""
        ])

    # Only include IMAGE_POSTGRES if it's not the default
    if image != 'postgres:17.5-alpine':
        lines.extend([
            "# Custom Image Source",
            f"IMAGE_POSTGRES={image}",
            ""
        ])

    return '\n'.join(lines)


def pull_image(ctx: Dict[str, Any], runner) -> None:
    """Pull PostgreSQL Docker image.

    The prebuilt flag controls whether we layer customizations on the image,
    NOT whether we pull it. Both modes may need to pull from registry.

    Args:
        ctx: Context dictionary with image URL and prebuilt flag
        runner: ActionRunner instance for side effects
    """
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')
    prebuilt = ctx.get('services.postgres.prebuilt', False)

    if prebuilt:
        runner.display(f"\nPulling prebuilt image (will use as-is): {image}")
    else:
        runner.display(f"\nPulling Docker image: {image}")

    # Always pull the image - both modes may need it from registry
    result = runner.run_shell(['docker', 'pull', image])

    if result.get('returncode') == 0:
        if prebuilt:
            runner.display(f"✓ Prebuilt image ready (no customizations): {image}")
        else:
            runner.display(f"✓ Image pulled: {image}")
    else:
        runner.display(f"✗ Failed to pull image: {image}")


def start_service(ctx: Dict[str, Any], runner) -> None:
    """Start PostgreSQL service.

    Calls make start command.

    Args:
        ctx: Context dictionary (unused)
        runner: ActionRunner instance for side effects
    """
    runner.display("Starting PostgreSQL service...")

    # Build command
    command = ['make', '-C', 'platform-infrastructure', 'start']

    # Execute command
    result = runner.run_shell(command)

    if result.get('returncode') == 0:
        runner.display("✓ PostgreSQL started successfully")
    else:
        runner.display("✗ PostgreSQL failed to start")
