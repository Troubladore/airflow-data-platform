"""PostgreSQL actions - GREEN phase implementation.

Key Design Decision: The 'prebuilt' Flag
=========================================
The prebuilt flag controls whether the platform LAYERS CUSTOMIZATIONS on the image,
NOT whether we pull it from the registry.

- prebuilt=false (default): Platform may add SSL certificates, Kerberos config,
  corporate CA certs, or other customizations at runtime or build time
- prebuilt=true: Use the image AS-IS without any platform modifications
  (image already has everything needed)

Both modes may need to pull the image from a Docker registry.
"""

from typing import Dict, Any


def save_config(ctx: Dict[str, Any], runner) -> None:
    """Save PostgreSQL configuration to platform-config.yaml and create .env file.

    Builds configuration dictionary from context and calls runner.save_config.
    Also creates platform-infrastructure/.env file required by Makefile.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects
    """
    # Build config dictionary
    # Map require_password boolean to auth_method
    require_password = ctx.get('services.postgres.require_password', True)
    auth_method = 'md5' if require_password else 'trust'
    password = ctx.get('services.postgres.password', 'changeme') if require_password else None

    # Store derived values back into state for later access
    ctx['services.postgres.auth_method'] = auth_method
    if password is not None:
        ctx['services.postgres.password'] = password

    config = {
        'services': {
            'postgres': {
                'enabled': True,
                'image': ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
                'prebuilt': ctx.get('services.postgres.prebuilt', False),
                'auth_method': auth_method,
                'password': password
            }
        }
    }

    # Call runner to save config
    runner.save_config(config, 'platform-config.yaml')

    # Create .env file for platform-bootstrap (central configuration)
    # This file is loaded by both Makefile and docker-compose.yml
    env_content = _build_env_file_content(
        platform_password=password or '',
        image=ctx.get('services.postgres.image', 'postgres:17.5-alpine'),
        openmetadata_enabled=ctx.get('services.openmetadata.enabled', False),
        kerberos_enabled=ctx.get('services.kerberos.enabled', False),
        pagila_enabled=ctx.get('services.pagila.enabled', False)
    )
    runner.write_file('platform-bootstrap/.env', env_content)


def _build_env_file_content(
    platform_password: str,
    image: str,
    openmetadata_enabled: bool = False,
    kerberos_enabled: bool = False,
    pagila_enabled: bool = False
) -> str:
    """Build .env file content from configuration values.

    Args:
        platform_password: PLATFORM_DB_PASSWORD value
        image: PostgreSQL image URL (optional, only included if non-default)
        openmetadata_enabled: Whether OpenMetadata service is enabled
        kerberos_enabled: Whether Kerberos service is enabled
        pagila_enabled: Whether Pagila service is enabled

    Returns:
        Complete .env file content as string
    """
    lines = [
        "# Platform Bootstrap Configuration",
        "# Auto-generated by wizard - DO NOT EDIT MANUALLY",
        "# Modify via: python -m wizard or ./platform setup",
        "",
        "# Service Enable Flags",
        f"ENABLE_OPENMETADATA={'true' if openmetadata_enabled else 'false'}",
        f"ENABLE_KERBEROS={'true' if kerberos_enabled else 'false'}",
        f"ENABLE_PAGILA={'true' if pagila_enabled else 'false'}",
        "",
        "# PostgreSQL Configuration",
        f"PLATFORM_DB_PASSWORD={platform_password}",
        ""
    ]

    # Only include service passwords if those services are enabled
    if openmetadata_enabled:
        lines.extend([
            "# Service user passwords",
            "OPENMETADATA_DB_PASSWORD=changeme_openmetadata_password",
            ""
        ])

    # Only include IMAGE_POSTGRES if it's not the default
    if image != 'postgres:17.5-alpine':
        lines.extend([
            "# Custom Image Source",
            f"IMAGE_POSTGRES={image}",
            ""
        ])

    return '\n'.join(lines)


def pull_image(ctx: Dict[str, Any], runner) -> None:
    """Pull PostgreSQL Docker image.

    The prebuilt flag controls whether we layer customizations on the image,
    NOT whether we pull it. Both modes may need to pull from registry.

    For corporate registry images (detected by having slashes), check if they
    exist locally first to avoid failing pulls from non-existent registries.

    Args:
        ctx: Context dictionary with image URL and prebuilt flag
        runner: ActionRunner instance for side effects
    """
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')
    prebuilt = ctx.get('services.postgres.prebuilt', False)

    # Check if this looks like a corporate registry image (has registry path)
    is_corporate_image = '/' in image.split(':')[0]  # Has registry/path before tag

    if is_corporate_image:
        # Check if image exists locally first
        check_result = runner.run_shell(['docker', 'image', 'inspect', image])
        if check_result.get('returncode') == 0:
            # Image exists locally
            if prebuilt:
                runner.display(f"\n‚úì Prebuilt image already exists locally: {image}")
            else:
                runner.display(f"\n‚úì Image already exists locally: {image}")
            return

    # Image doesn't exist locally or is from Docker Hub - attempt pull
    if prebuilt:
        runner.display(f"\nPulling prebuilt image (will use as-is): {image}")
    else:
        runner.display(f"\nPulling Docker image: {image}")

    # Pull the image from registry
    result = runner.run_shell(['docker', 'pull', image])

    if result.get('returncode') == 0:
        if prebuilt:
            runner.display(f"‚úì Prebuilt image ready (no customizations): {image}")
        else:
            runner.display(f"‚úì Image pulled: {image}")
    else:
        runner.display(f"‚úó Failed to pull image: {image}")


def start_service(ctx: Dict[str, Any], runner) -> None:
    """Start PostgreSQL service with automatic diagnostics on failure.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects
    """
    runner.display("Starting PostgreSQL service...")

    # Show configuration being used
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')
    auth_method = ctx.get('services.postgres.auth_method', 'trust')

    runner.display(f"  Image: {image}")
    runner.display(f"  Auth: {auth_method} {'(no password)' if auth_method == 'trust' else '(password required)'}")

    # Build command
    command = ['make', '-C', 'platform-infrastructure', 'start']

    # Execute command
    result = runner.run_shell(command)

    if result.get('returncode') == 0:
        runner.display("‚úì PostgreSQL started successfully")
    else:
        runner.display("‚úó PostgreSQL failed to start")
        runner.display("")
        runner.display("Running automatic diagnostics...")
        runner.display("")

        # Run comprehensive diagnostics automatically
        _run_postgres_diagnostics(ctx, runner, result)

def _run_postgres_diagnostics(ctx: Dict[str, Any], runner, start_result) -> None:
    """Run automatic diagnostics when PostgreSQL fails to start.

    Shows important info on screen, saves verbose details to log.
    """
    import datetime
    import os

    # Create log file with timestamp
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = f"postgres_diagnostic_{timestamp}.log"

    # Collect diagnostic information
    diagnostics = []

    # 1. Check if container was created
    container_check = runner.run_shell(['docker', 'ps', '-a', '--format', '{{.Names}}'])
    container_exists = 'platform-postgres' in container_check.get('stdout', '')

    if not container_exists:
        runner.display("‚ùå Container was not created - Docker Compose failed")
        diagnostics.append("CRITICAL: Container platform-postgres was never created")

        # Check docker-compose validation
        compose_check = runner.run_shell(
            ['docker', 'compose', '-f', 'platform-infrastructure/docker-compose.yml', 'config']
        )
        if compose_check.get('returncode') != 0:
            runner.display("  ‚Ä¢ docker-compose.yml has syntax errors")
            diagnostics.append(f"Docker Compose validation failed:\n{compose_check.get('stderr', '')}")
    else:
        runner.display("‚ö† Container was created but failed to start/stay running")

        # Get container logs
        logs_result = runner.run_shell(['docker', 'logs', 'platform-postgres', '--tail', '50'])
        diagnostics.append(f"Container logs:\n{logs_result.get('stdout', '')}\n{logs_result.get('stderr', '')}")

    # 2. Check image status
    image = ctx.get('services.postgres.image', 'postgres:17.5-alpine')
    image_check = runner.run_shell(['docker', 'image', 'inspect', image])

    if image_check.get('returncode') != 0:
        runner.display(f"  ‚Ä¢ Image not found locally: {image}")

        # Check if it's a corporate registry
        if '/' in image.split(':')[0]:
            runner.display("  ‚Ä¢ Corporate registry detected - may need authentication")
            runner.display(f"  ‚Ä¢ Try: docker pull {image}")
        diagnostics.append(f"Image {image} not found locally")

    # 3. Parse error messages from make output
    stderr = start_result.get('stderr', '')
    stdout = start_result.get('stdout', '')
    combined_output = stderr + '\n' + stdout

    # Common error patterns and solutions
    if 'pull access denied' in combined_output:
        runner.display("  ‚Ä¢ Registry requires authentication")
        runner.display(f"  ‚Ä¢ Solution: docker login {image.split('/')[0]}")
        diagnostics.append("ERROR: Pull access denied - registry requires authentication")

    elif 'manifest unknown' in combined_output or 'manifest for' in combined_output:
        runner.display(f"  ‚Ä¢ Image not found in registry: {image}")
        runner.display("  ‚Ä¢ Check image name and tag are correct")
        diagnostics.append(f"ERROR: Image {image} not found in registry")

    elif 'toomanyrequests' in combined_output:
        runner.display("  ‚Ä¢ Docker Hub rate limit exceeded")
        runner.display("  ‚Ä¢ Wait 6 hours or authenticate: docker login")
        diagnostics.append("ERROR: Docker Hub rate limit exceeded")

    elif 'address already in use' in combined_output:
        runner.display("  ‚Ä¢ Port 5432 is already in use")

        # Check what's using the port
        port_check = runner.run_shell(['lsof', '-i', ':5432'])
        if port_check.get('stdout'):
            runner.display("  ‚Ä¢ Process using port:")
            for line in port_check.get('stdout', '').split('\n')[:3]:
                if line.strip():
                    runner.display(f"    {line}")
        diagnostics.append("ERROR: Port 5432 already in use")

    elif 'no space left' in combined_output:
        runner.display("  ‚Ä¢ Disk space issue")

        # Check disk space
        df_result = runner.run_shell(['df', '-h', '/var/lib/docker'])
        if df_result.get('stdout'):
            runner.display("  ‚Ä¢ Docker storage:")
            runner.display(f"    {df_result.get('stdout', '').split('\n')[1]}")
        runner.display("  ‚Ä¢ Clean up: docker system prune -a")
        diagnostics.append("ERROR: No disk space available")

    # 4. Check network
    network_check = runner.run_shell(['docker', 'network', 'ls', '--format', '{{.Name}}'])
    if 'platform_network' not in network_check.get('stdout', ''):
        runner.display("  ‚Ä¢ platform_network missing - will be created")
        diagnostics.append("INFO: platform_network will be created on first start")

    # 5. Save detailed diagnostics to file
    runner.display("")
    runner.display(f"üíæ Full diagnostics saved to: {log_file}")

    # Write comprehensive log
    with open(log_file, 'w') as f:
        f.write(f"PostgreSQL Startup Diagnostics - {datetime.datetime.now()}\n")
        f.write("=" * 70 + "\n\n")

        f.write("CONFIGURATION:\n")
        f.write(f"  Image: {image}\n")
        f.write(f"  Auth Method: {ctx.get('services.postgres.auth_method', 'trust')}\n")
        f.write(f"  Port: {ctx.get('services.postgres.port', 5432)}\n\n")

        f.write("DOCKER COMPOSE OUTPUT:\n")
        f.write(combined_output + "\n\n")

        f.write("DIAGNOSTIC DETAILS:\n")
        for diag in diagnostics:
            f.write(diag + "\n\n")

        f.write("\nRECOMMENDED NEXT STEPS:\n")
        f.write("1. Review the errors above\n")
        f.write("2. If using corporate registry, ensure docker login completed\n")
        f.write("3. Try manual start: cd platform-infrastructure && docker compose up\n")
        f.write("4. Share this log file if requesting help\n")

    runner.display("")
    runner.display("To view full details: cat " + log_file)
    runner.display("To try manual start: cd platform-infrastructure && docker compose up")
