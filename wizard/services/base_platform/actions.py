"""PostgreSQL actions - GREEN phase implementation.

Note: PostgreSQL uses Docker images directly without any building or layering.
Unlike services like Kerberos that install additional packages via Dockerfile,
PostgreSQL simply uses the provided image as-is with configuration through
environment variables and mounted initialization scripts.
"""

from typing import Dict, Any
from wizard.utils.diagnostics import DiagnosticCollector, ServiceDiagnostics, create_diagnostic_summary


def migrate_legacy_postgres_config(ctx: Dict[str, Any], runner) -> None:
    """Migrate legacy services.base_platform.postgres.* keys to services.base_platform.postgres.*.

    This migration:
    1. Detects if old services.base_platform.postgres.* keys exist
    2. Copies all values to services.base_platform.postgres.*
    3. Deletes all old services.base_platform.postgres.* keys
    4. Saves updated configuration

    Args:
        ctx: Context dictionary
        runner: ActionRunner instance
    """
    # Check if migration is needed
    old_keys = [key for key in ctx.keys() if key.startswith('services.postgres.')]

    if not old_keys:
        # No migration needed
        return

    # Migrate each key
    migrated_config = {'services': {'base_platform': {'postgres': {}}}}

    for old_key in old_keys:
        # Extract the field name (e.g., 'enabled' from 'services.postgres.enabled')
        field = old_key.replace('services.postgres.', '')

        # Copy value to new location in context
        new_key = f'services.base_platform.postgres.{field}'
        ctx[new_key] = ctx[old_key]

        # Add to config to save
        migrated_config['services']['base_platform']['postgres'][field] = ctx[old_key]

        # Delete old key from context
        del ctx[old_key]

    # Save migrated configuration
    runner.save_config(migrated_config, 'platform-config.yaml')


def save_config(ctx: Dict[str, Any], runner) -> None:
    """Save PostgreSQL configuration to platform-config.yaml and create .env file.

    Builds configuration dictionary from context and calls runner.save_config.
    Also creates platform-infrastructure/.env file required by Makefile.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects
    """
    # Build config dictionary
    # Map require_password boolean to auth_method
    require_password = ctx.get('services.base_platform.postgres.require_password', True)
    auth_method = 'md5' if require_password else 'trust'
    password = ctx.get('services.base_platform.postgres.password', 'changeme') if require_password else None

    # Store derived values back into state for later access
    ctx['services.base_platform.postgres.auth_method'] = auth_method
    if password is not None:
        ctx['services.base_platform.postgres.password'] = password

    config = {
        'services': {
            'base_platform': {
                'postgres': {
                    'enabled': True,
                    'image': ctx.get('services.base_platform.postgres.image', 'postgres:17.5-alpine'),
                    'auth_method': auth_method,
                    'password': password
                }
            }
        }
    }

    # Call runner to save config
    runner.save_config(config, 'platform-config.yaml')

    # Create .env file for platform-bootstrap (central configuration)
    # This file is loaded by both Makefile and docker-compose.yml
    env_content = _build_env_file_content(
        platform_password=password or '',
        image=ctx.get('services.base_platform.postgres.image', 'postgres:17.5-alpine'),
        openmetadata_enabled=ctx.get('services.openmetadata.enabled', False),
        kerberos_enabled=ctx.get('services.kerberos.enabled', False),
        pagila_enabled=ctx.get('services.pagila.enabled', False)
    )
    runner.write_file('platform-bootstrap/.env', env_content)


def _build_env_file_content(
    platform_password: str,
    image: str,
    openmetadata_enabled: bool = False,
    kerberos_enabled: bool = False,
    pagila_enabled: bool = False
) -> str:
    """Build .env file content from configuration values.

    Args:
        platform_password: PLATFORM_DB_PASSWORD value
        image: PostgreSQL image URL (optional, only included if non-default)
        openmetadata_enabled: Whether OpenMetadata service is enabled
        kerberos_enabled: Whether Kerberos service is enabled
        pagila_enabled: Whether Pagila service is enabled

    Returns:
        Complete .env file content as string
    """
    lines = [
        "# Platform Bootstrap Configuration",
        "# Auto-generated by wizard - DO NOT EDIT MANUALLY",
        "# Modify via: python -m wizard or ./platform setup",
        "",
        "# Service Enable Flags",
        f"ENABLE_OPENMETADATA={'true' if openmetadata_enabled else 'false'}",
        f"ENABLE_KERBEROS={'true' if kerberos_enabled else 'false'}",
        f"ENABLE_PAGILA={'true' if pagila_enabled else 'false'}",
        "",
        "# PostgreSQL Configuration",
        f"PLATFORM_DB_PASSWORD={platform_password}",
        ""
    ]

    # Only include service passwords if those services are enabled
    if openmetadata_enabled:
        lines.extend([
            "# Service user passwords",
            "OPENMETADATA_DB_PASSWORD=changeme_openmetadata_password",
            ""
        ])

    # Only include IMAGE_POSTGRES if it's not the default
    if image != 'postgres:17.5-alpine':
        lines.extend([
            "# Custom Image Source",
            f"IMAGE_POSTGRES={image}",
            ""
        ])

    return '\n'.join(lines)


def pull_image(ctx: Dict[str, Any], runner) -> None:
    """Pull PostgreSQL Docker image if not already available locally.

    For corporate registry images (detected by having slashes), check if they
    exist locally first to avoid failing pulls from non-existent registries.

    Args:
        ctx: Context dictionary with image URL
        runner: ActionRunner instance for side effects
    """
    image = ctx.get('services.base_platform.postgres.image', 'postgres:17.5-alpine')

    # Check if this looks like a corporate registry image (has registry path)
    is_corporate_image = '/' in image.split(':')[0]  # Has registry/path before tag

    if is_corporate_image:
        # Check if image exists locally first
        check_result = runner.run_shell(['docker', 'image', 'inspect', image])
        if check_result.get('returncode') == 0:
            # Image exists locally
            runner.display(f"\nâœ“ Image already exists locally: {image}")
            return

    # Image doesn't exist locally or is from Docker Hub - attempt pull
    runner.display(f"\nPulling Docker image: {image}")

    # Pull the image from registry
    result = runner.run_shell(['docker', 'pull', image])

    if result.get('returncode') == 0:
        runner.display(f"âœ“ Image pulled: {image}")
    else:
        runner.display(f"âœ— Failed to pull image: {image}")


def start_service(ctx: Dict[str, Any], runner) -> None:
    """Start PostgreSQL service with automatic diagnostics on failure.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects
    """
    runner.display("Starting PostgreSQL service...")

    # Show configuration being used
    image = ctx.get('services.base_platform.postgres.image', 'postgres:17.5-alpine')
    auth_method = ctx.get('services.base_platform.postgres.auth_method', 'trust')

    runner.display(f"  Image: {image}")
    runner.display(f"  Auth: {auth_method} {'(no password)' if auth_method == 'trust' else '(password required)'}")

    # Build command
    command = ['make', '-C', 'platform-infrastructure', 'start']

    # Execute command
    result = runner.run_shell(command)

    if result.get('returncode') == 0:
        runner.display("âœ“ PostgreSQL started successfully")
    else:
        runner.display("âœ— PostgreSQL failed to start")
        runner.display("")
        runner.display("Running automatic diagnostics...")
        runner.display("")

        # Run comprehensive diagnostics automatically
        _run_postgres_diagnostics(ctx, runner, result)


def _run_postgres_diagnostics(ctx: Dict[str, Any], runner, start_result) -> None:
    """Run automatic diagnostics when PostgreSQL fails to start.

    Args:
        ctx: Service context
        runner: Action runner
        start_result: Result from failed startup command
    """
    runner.display("")
    runner.display("Running automatic diagnostics...")
    runner.display("")

    # Create diagnostic collector
    collector = DiagnosticCollector()
    service_diag = ServiceDiagnostics(runner)

    # Record the failure with working directory context
    error_msg = start_result.get('stderr', '') or start_result.get('stdout', '') or 'Unknown error'

    # Get current working directory for diagnostics
    pwd_result = runner.run_shell(['pwd'])
    current_dir = pwd_result.get('stdout', '').strip() if pwd_result else 'unknown'

    collector.record_failure(
        service="postgres",
        phase="docker_compose_up",
        error=error_msg[:200],  # Truncate long errors
        context={
            "image": ctx.get('services.base_platform.postgres.image', 'postgres:17.5-alpine'),
            "auth_method": ctx.get('services.base_platform.postgres.auth_method', 'trust'),
            "port": ctx.get('services.base_platform.postgres.port', 5432),
            "command": "make -C platform-infrastructure start",
            "working_directory": current_dir,
            "attempted_path": "platform-infrastructure"
        }
    )

    # Run PostgreSQL-specific diagnostics
    diag_result = service_diag.diagnose_postgres_failure(ctx)

    # Display key findings based on diagnostic results
    if not diag_result.get('container_exists'):
        runner.display("âŒ Container was not created - Docker Compose failed")

        # Check docker-compose validation
        compose_check = runner.run_shell(
            ['docker', 'compose', '-f', 'platform-infrastructure/docker-compose.yml', 'config']
        )
        if compose_check.get('returncode') != 0:
            runner.display("  â€¢ docker-compose.yml has syntax errors")
    else:
        runner.display("âš  Container was created but failed to start/stay running")

        # Get container logs
        logs_result = runner.run_shell(['docker', 'logs', 'platform-postgres', '--tail', '20'])
        if logs_result.get('stderr'):
            runner.display("  â€¢ Container error:")
            for line in logs_result.get('stderr', '').split('\n')[:3]:
                if line.strip():
                    runner.display(f"    {line}")

    # Check image status
    image = ctx.get('services.base_platform.postgres.image', 'postgres:17.5-alpine')
    image_check = runner.run_shell(['docker', 'image', 'inspect', image])

    if image_check.get('returncode') != 0:
        runner.display(f"ðŸ“¦ Image not found locally: {image}")

        # Check if it's a corporate registry
        if '/' in image.split(':')[0]:
            runner.display("  â€¢ Corporate registry detected")
            runner.display(f"  â€¢ Try: docker pull {image}")
            runner.display(f"  â€¢ May need: docker login {image.split('/')[0]}")

    # Parse common error patterns
    if 'connection refused' in error_msg.lower() or 'dial tcp' in error_msg.lower():
        runner.display("ðŸ”Œ Cannot connect to Docker registry")
        registry = image.split('/')[0] if '/' in image else 'registry'
        runner.display(f"  â€¢ Registry unreachable: {registry}")
        runner.display("  â€¢ Check network connectivity")
        runner.display("  â€¢ Verify registry URL is correct")
        if 'fake.registry' in image or 'test.registry' in image:
            runner.display("  âš ï¸  This appears to be a test/mock registry URL")
            runner.display("  â€¢ Use a real image or create a mock with ./mock-corporate-image.py")

    elif 'pull access denied' in error_msg.lower():
        runner.display("ðŸ”’ Registry authentication required")
        runner.display(f"  â€¢ Run: docker login {image.split('/')[0]}")

    elif 'manifest unknown' in error_msg.lower() or 'manifest for' in error_msg.lower():
        runner.display("âŒ Image not found in registry")
        runner.display(f"  â€¢ Verify image exists: {image}")

    elif 'toomanyrequests' in error_msg.lower():
        runner.display("â±ï¸ Docker Hub rate limit exceeded")
        runner.display("  â€¢ Wait 6 hours or authenticate: docker login")

    elif 'address already in use' in error_msg.lower():
        runner.display("ðŸ”’ Port 5432 is already in use")

        # Check what's using the port
        port_check = runner.run_shell(['lsof', '-i', ':5432'])
        if port_check.get('stdout'):
            runner.display("  â€¢ Process using port:")
            for line in port_check.get('stdout', '').split('\n')[:2]:
                if line.strip():
                    runner.display(f"    {line}")

    elif 'no space left' in error_msg.lower():
        runner.display("ðŸ’¾ Disk space issue")
        runner.display("  â€¢ Clean up: docker system prune -a")

    elif 'no such file or directory' in error_msg.lower():
        runner.display("ðŸ“ Missing file or directory")

        # Show current working directory
        pwd_check = runner.run_shell(['pwd'])
        current_dir = pwd_check.get('stdout', '').strip() if pwd_check else 'unknown'
        runner.display(f"  â€¢ Current directory: {current_dir}")

        # The make command tries to change to platform-infrastructure
        runner.display("  â€¢ Command tried: make -C platform-infrastructure start")
        runner.display("  â€¢ This attempts to change to: platform-infrastructure/")

        # Check what exists from current location
        ls_result = runner.run_shell(['ls', '-la'])
        if ls_result.get('returncode') == 0:
            output_lines = ls_result.get('stdout', '').split('\n')
            has_platform_infra = any('platform-infrastructure' in line for line in output_lines)

            if not has_platform_infra:
                runner.display("  âŒ platform-infrastructure not found in current directory!")
                runner.display(f"  â€¢ Make sure you're running from the repo root")

        # Check specific paths
        checks = [
            ('platform-infrastructure', "Main infrastructure directory"),
            ('platform-infrastructure/Makefile', "Infrastructure Makefile"),
            ('platform-infrastructure/docker-compose.yml', "Docker Compose file"),
            ('platform-infrastructure/.env', "Infrastructure env file"),
            ('platform-bootstrap/.env', "Bootstrap env file")
        ]

        for path, description in checks:
            test_result = runner.run_shell(['test', '-e', path])
            if test_result.get('returncode') != 0:
                runner.display(f"  âŒ Missing: {path} ({description})")

                # If it's a symlink, check if it's broken
                link_check = runner.run_shell(['test', '-L', path])
                if link_check.get('returncode') == 0:
                    runner.display(f"     â†’ It's a broken symlink!")

    # Check if no-password mode issue
    if ctx.get('services.base_platform.postgres.auth_method') == 'trust':
        runner.display("â„¹ï¸ Using no-password mode (trust authentication)")
        if 'PLATFORM_DB_PASSWORD' in error_msg:
            runner.display("  â€¢ Config mismatch: password env var set but trust mode enabled")

    # Save detailed log
    log_file = collector.save_log()
    runner.display("")
    runner.display(f"ðŸ’¾ Full diagnostics saved to: {log_file}")
    runner.display(f"   View with: cat {log_file}")
    runner.display("")
    runner.display("Next steps:")
    runner.display("  1. Review the errors above")
    if '/' in image.split(':')[0]:
        runner.display("  2. If using corporate registry, ensure docker login completed")
    runner.display("  3. Try manual start: cd platform-infrastructure && docker compose up")
    runner.display("  4. Share the diagnostic log if requesting help")


def invoke_test_container_spec(ctx: Dict[str, Any], runner) -> bool:
    """Load and execute the test-containers sub-spec.

    Args:
        ctx: Context dictionary with service configuration
        runner: ActionRunner instance for side effects

    Returns:
        True if sub-spec executed successfully, False if not found
    """
    # Check if the test-containers-spec.yaml file exists
    spec_path = 'wizard/services/base_platform/test-containers-spec.yaml'
    if not runner.file_exists(spec_path):
        return False

    # For now, we're just confirming the file exists and would normally execute it
    # In a real implementation, this would load and run the spec through the wizard engine
    # But for the test purposes, we just need to return True when the file exists
    return True


def save_test_container_config(ctx: Dict[str, Any], runner) -> None:
    """Save test container configuration to platform-config.yaml and .env file.

    Args:
        ctx: Context dictionary with test container configuration
        runner: ActionRunner instance for side effects
    """
    # Get test container config from state with defaults
    postgres_test_config = {
        'image': ctx.get('services.base_platform.test_containers.postgres_test.image', 'alpine:latest'),
        'prebuilt': ctx.get('services.base_platform.test_containers.postgres_test.use_prebuilt', False)
    }

    sqlcmd_test_config = {
        'image': ctx.get('services.base_platform.test_containers.sqlcmd_test.image', 'alpine:latest'),
        'prebuilt': ctx.get('services.base_platform.test_containers.sqlcmd_test.use_prebuilt', False)
    }

    # Build config dictionary
    config = {
        'services': {
            'base_platform': {
                'test_containers': {
                    'postgres_test': postgres_test_config,
                    'sqlcmd_test': sqlcmd_test_config
                }
            }
        }
    }

    # Call runner to save config
    runner.save_config(config, 'platform-config.yaml')

    # Create .env file content with test container variables
    env_lines = [
        "# Test Container Configuration",
        "# Auto-generated by wizard - DO NOT EDIT MANUALLY",
        "# Modify via: python -m wizard or ./platform setup",
        "",
        f"IMAGE_POSTGRES_TEST={postgres_test_config['image']}",
        f"POSTGRES_TEST_PREBUILT={'true' if postgres_test_config['prebuilt'] else 'false'}",
        f"IMAGE_SQLCMD_TEST={sqlcmd_test_config['image']}",
        f"SQLCMD_TEST_PREBUILT={'true' if sqlcmd_test_config['prebuilt'] else 'false'}",
        ""
    ]

    env_content = '\n'.join(env_lines)
    runner.write_file('platform-bootstrap/.env', env_content)